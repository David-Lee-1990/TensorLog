TUTORIAL/DOCS

  see docs/README.txt

Trip work:
 - spent time stabilizing the learner on grid task.  progress but learning
 rate still needs to be tuned by grid size....
  - no regularizer arguments for expt yet TODO
 - problems mostly were lack of regularization and exploding gradients  
 - learner now has regularizer and clips gradients and parameters correctlu
 - major cleanup of mutil
 - regularization seems slow for wnet task compared to previously....
 - explored using Log before SoftMax to make it more stable but experiments were disappointing, learning
 seemed much much slower.....
 - wrote debug.py
 - refactored preimages
 - tested sparse weight vectors - seem to work

TODO: Thinking thru functions and re-use: I'm not sure that re-used functions are handled properly.
They cache their outputs so if they are called multiple times at the same level with different
inputs we really need a copy of each instance. Proposed test case:

 	 p(X,Y) :- q(X,Y),r(Y,Z),r(X,W).
	 q(a,b)
	 r(X,Y) :- s(X,Y).  # so it's a re-used function
	 s(a,c). s(b,c).

BUGS: 

 - weights should work with a sparse parameter vector - ok?
 - head p(X,X) doesn't work

CLEANUPS:
 - clean up experiments to use expv2 and clean out the dead code

DESIGN FLAWS: 1 fails but 2 is ok even tho both are polytrees.

 1 p(X,Y) :- q(X,X1),r(Y,Y1),s(X1,Y1)
 2 p(X,Y) :- q(X,X1),s(X1,Y1),r(Y,Y1)

EXTENSIONS:
 - throw sensible error when a novel rule constant is seen

config:
 - might want to include, in config.py, an overall 'top' configuration
 which includes the others as subconfigurations.  also might want to
 serialize/deserialize them.

learning:
 - serializable multi-task datasets
  propprExamplesAsData(db,fileName): convert to provide (xdict,ydict) outputs
 - adagrad & holdout set for convergence
 - multithreading

MORE EXPERIMENTS:

 - Rose's representation learning/recommendation
 - SSL

Structure learning notes:
 - se is "superedge", ise is inverse superedge

phase 1, get last arguments of if(Q,R), ifinv(Q,R), chain(P,Q,R).
phase1 is used as edge in transitive closure/rwr type rules with
positive examples of any relation.

phase1(X,Y) :- 
	  se(X,RY),f2(RY,Y),
	  f1(RY,Y), weight_if2(R).
phase1(X,Y) :- 
	  ise(X,RY),f2(RY,Y),
	  f1(RY,Y), weight_ifinv2(R).
phase1(X,Y) :-
	  se(X,QZ),f2(QZ,Z),se(Z,RY),f2(RY,Y)
	  f1(RY,R),weight_chain3(R).

phase2, get penultinate arguments. We will specialize this theory for
the r's with high weights from phase1, and then use phase2 as initial
step in transitive closure rules for facts Q,X,Y [work this out...]

phase2(QX,Y) :- phase2_r1(QX,Y).
phase2(QX,Y) :- phase2_r2(QX,Y).
...
phase2_r(QX,Y) :- 
	  f2(QX,X),r(X,Y),
	  f1(QX,Q),weight_if1(Q).
...
phase2_r(QX,Y) :- 
	  f2(QX,X),r(Y,X),
	  f1(QX,Q),weight_ifinv1(Q).
...
phase2_r(X,Y) :-
	  se(X,QZ),f2(QZ,Z),r(Z,Y),
	  f1(QZ,Q),weight_chain2_r(Q).

phase3 for chains only:

phase2_rq(PX,Y) :-
	  f2(PX,X),q(X,Z),r(Z,Y)
	  f1(PX,P),weight_chain1_rq(P).



-------------------- better trace output --------------------

Build and/or examine the tree?
 - show function tree (which has results) with line numbers
 - expand/close line k with +k/-k -- also shows some outputs
 - view attributes of output: +k r1,...,rm : for row r, +k : c1,..,cm for columns c

What about backprop values? can I also see deltas at each function
node?  A function might be called multiple times with different inputs
of course... should I consider this? what happens with that now?  does
the self.result bit for recursive calls work properly? 

self.result should probably be self.output

-------------------- grids -------------------- 

what the heck does the visualization show?

	      
SoftmaxFunction: path(i,o) = ...
  SumFunction: path(i,o)/1 = ...
    OpSeqFunction(['X']): path(X,Y) :- edge(X,Y). = ... /1
      eval VecMatMulOp('f_1_Y','X',edge(i,o),False)
  OpSeqFunction(['X']):	  path(X,Y) :- edge(X,Z), path(Z,Y). = ... /1
      eval VecMatMulOp('f_1_Z','X',edge(i,o),False)
      eval DefinedPredOp('f_2_Y','f_1_Z',path(i,o),1) 
         SumFunction: path(i,o)/2
            OpSeqFunction(['X']):  path(X,Y) :- edge(X,Y). /2
               eval VecMatMulOp('f_1_Y','X',edge(i,o),False) max 2.25
            OpSeqFunction(['X']):  path(X,Y) :- edge(X,Z), path(Z,Y). /2
               eval VecMatMulOp('f_1_Z','X',edge(i,o),False) max 2.25
               eval DefinedPredOp('f_2_Y','f_1_Z',path(i,o),2)
                  NullFunction()
